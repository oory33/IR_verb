(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
n = n + 1
}
output <- preout[(bufflength + min + 1):(length(sig) + min)]
output
#save wav
dat <- Wave(left=output, right=output, samp.rate=48000, bit=32, pcm=TRUE)
setwd("/Users/ryo/Desktop/my/FDN/output/4th")
writeWave(normalize(dat, unit="32", center=TRUE), filename=sprintf("%s_%05d.wav",  substring(fname, 1, (nchar(fname)- 4)), cutoff))
#make buffer
out <- numeric(length(signal))
wav <- fname
signal <- readWave(wav)@left
setwd("/Users/ryo/Desktop/my/FDN/input")
wav <- fname
signal <- readWave(wav)@left
srate <- readWave(wav)@samp.rate
##set parameter
c1_delay <- 31
c1_gain <- 0.6
c2_delay <- 47
c2_gain <- 0.6
c3_delay <- 89
c3_gain <- 0.6
c4_delay <- 97
c4_gain <- 0.5
c5_delay <- 101
c5_gain <- 0.6
c6_delay <- 103
c6_gain <- 0.6
c7_delay <- 107
c7_gain <- 0.6
c8_delay <- 109
c8_gain <- 0.5
cutoff <- 5000
mix <- 0.4
##convert coefficients
d1 <- srate * c1_delay / 1000
d2 <- srate * c2_delay / 1000
d3 <- srate * c3_delay / 1000
d4 <- srate * c4_delay / 1000
d5 <- srate * c5_delay / 1000
d6 <- srate * c6_delay / 1000
d7 <- srate * c7_delay / 1000
d8 <- srate * c8_delay / 1000
g1 <- c1_gain
g2 <- c2_gain
g3 <- c3_gain
g4 <- c4_gain
g5 <- c5_gain
g6 <- c6_gain
g7 <- c7_gain
g8 <- c8_gain
##buffer for maimum delay time
bufflength <- max(d1, d2, d3, d4, d5, d6, d7, d8)
min <- min(d1, d2, d3, d4, d5, d6, d7, d8)
#make buffer
out <- numeric(length(signal))
buf1 <- c(out,out)
buf2 <- buf1
buf3 <- buf1
buf4 <- buf1
buf5 <- buf1
buf6 <- buf1
buf7 <- buf1
buf8 <- buf1
##coefficients of LPF
fn = srate / 2
ff = cutoff / fn
fp = ff * pi
b1 = 1
b2 = 0.12
a1 = 1
a2 = exp((-1) * fp)
norm = (1 - a2) / (b1 + b2)
b1 = b1 * norm
b2 = b2 * norm
##coefficients for matrix
gp = 1 / sqrt(2)
gn = -1 * gp
q = 1 / sqrt(2)
##LPF
n <- 1
while(n <= length(signal)) {
if(n == 1){
out[n] <- signal[n]
n = n + 1
} else {
outb1 <- signal[n] * b1
outb2 <- signal[(n-1)] * b2
out[n] <- outb1 + outb2 + (out[(n-1)] * a2)
n = n + 1
}
}
#save wav
dat <- Wave(left=out, right=out, samp.rate=48000, bit=32, pcm=TRUE)
setwd("/Users/ryo/Desktop/my/FDN/output/4th")
writeWave(normalize(dat, unit="32", center=TRUE), filename=sprintf("%s_%05d.wav",  substring(fname, 1, (nchar(fname)- 4)), cutoff))
setwd("/Users/ryo/Desktop/my/FDN/input")
cutoff <- 100
mix <- 0.4
##convert coefficients
d1 <- srate * c1_delay / 1000
d2 <- srate * c2_delay / 1000
d3 <- srate * c3_delay / 1000
d4 <- srate * c4_delay / 1000
d5 <- srate * c5_delay / 1000
d6 <- srate * c6_delay / 1000
d7 <- srate * c7_delay / 1000
d8 <- srate * c8_delay / 1000
g1 <- c1_gain
g2 <- c2_gain
g3 <- c3_gain
g4 <- c4_gain
g5 <- c5_gain
g6 <- c6_gain
g7 <- c7_gain
g8 <- c8_gain
##buffer for maimum delay time
bufflength <- max(d1, d2, d3, d4, d5, d6, d7, d8)
min <- min(d1, d2, d3, d4, d5, d6, d7, d8)
#make buffer
out <- numeric(length(signal))
buf1 <- c(out,out)
buf2 <- buf1
buf3 <- buf1
buf4 <- buf1
buf5 <- buf1
buf6 <- buf1
buf7 <- buf1
buf8 <- buf1
##coefficients of LPF
fn = srate / 2
ff = cutoff / fn
fp = ff * pi
b1 = 1
b2 = 0.12
a1 = 1
a2 = exp((-1) * fp)
norm = (1 - a2) / (b1 + b2)
b1 = b1 * norm
b2 = b2 * norm
##coefficients for matrix
gp = 1 / sqrt(2)
gn = -1 * gp
q = 1 / sqrt(2)
##LPF
n <- 1
while(n <= length(signal)) {
if(n == 1){
out[n] <- signal[n]
n = n + 1
} else {
outb1 <- signal[n] * b1
outb2 <- signal[(n-1)] * b2
out[n] <- outb1 + outb2 + (out[(n-1)] * a2)
n = n + 1
}
}
#save wav
dat <- Wave(left=out, right=out, samp.rate=48000, bit=32, pcm=TRUE)
setwd("/Users/ryo/Desktop/my/FDN/output/4th")
writeWave(normalize(dat, unit="32", center=TRUE), filename=sprintf("%s_%05d.wav",  substring(fname, 1, (nchar(fname)- 4)), cutoff))
setwd("/Users/ryo/Desktop/my/FDN/input")
#fit zero to head
sig <- c(numeric(bufflength), out)
preout <- c(numeric(length(sig)))
##FDN
n <- bufflength + 1
plot(sig, type="l")
while(n <= length(sig) + min){
preout[n] <- ((((buf1[(n-d1)] * g1) + (buf2[(n-d2)] * g2) +
(buf3[(n-d3)] * g3) + (buf4[(n-d4)] * g4) +
(buf5[(n-d5)] * g5) + (buf6[(n-d6)] * g6) +
(buf7[(n-d7)] * g7) + (buf8[(n-d8)] * g8)) / 8) * (1 - mix)
+ (sig[(n - min)] * mix))
buf1[n] <- sig[n] + ((buf2[(n-d2)] * gp) + (buf3[(n-d3)] * gp)+
(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
buf2[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gn)+
(buf5[(n-d5)] * gp) + (buf8[(n-d8)] * gn)) * q
buf3[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gp)+
(buf5[(n-d5)] * gn) + (buf8[(n-d8)] * gp)) * q
buf4[n] <- sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn)+
(buf6[(n-d6)] * gn) + (buf7[(n-d7)] * gn)) * q
buf5[n] <- sig[n] + ((buf2[(n-d2)] * gp) + (buf3[(n-d3)] * gp)+
(buf6[(n-d6)] * gn) + (buf7[(n-d7)] * gn)) * q
buf6[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gp)+
(buf5[(n-d5)] * gn) + (buf8[(n-d8)] * gp)) * q
buf7[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gn)+
(buf5[(n-d5)] * gp) + (buf8[(n-d8)] * gp)) * q
buf8[n] <- sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn)+
(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
n = n + 1
}
plot(preout, type="l")
sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn)+
(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
##FDN
n <- bufflength + 1
buf8[n] <- sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn)+
(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn)+
(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
n = srate * 5
sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn)+
(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
gp
gn
((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn)+
(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp))
((buf2[(n-d2)] * gn)
(buf2[(n-d2)] * gn)
)
buf6[(n-d6)] * gp
buf6[(n-d6)]
#make buffer
out <- numeric(length(signal))
buf1 <- c(out,out)
buf2 <- buf1
buf3 <- buf1
buf4 <- buf1
buf5 <- buf1
buf6 <- buf1
buf7 <- buf1
buf8 <- buf1
buf2[(n-d2)] * gn
sig
##LPF
n <- 1
while(n <= length(signal)) {
if(n == 1){
out[n] <- signal[n]
n = n + 1
} else {
outb1 <- signal[n] * b1
outb2 <- signal[(n-1)] * b2
out[n] <- outb1 + outb2 + (out[(n-1)] * a2)
n = n + 1
}
}
plot(sig, type="l")
##FDN
n <- bufflength + 1
1 - mix
sig[(n - min)]
while(n <= length(sig) + min){
preout[n] <- ((((buf1[(n-d1)] * g1) + (buf2[(n-d2)] * g2) +
(buf3[(n-d3)] * g3) + (buf4[(n-d4)] * g4) +
(buf5[(n-d5)] * g5) + (buf6[(n-d6)] * g6) +
(buf7[(n-d7)] * g7) + (buf8[(n-d8)] * g8)) / 8) * (1 - mix)
+ (sig[(n - min)] * mix))
buf1[n] <- sig[n] + ((buf2[(n-d2)] * gp) + (buf3[(n-d3)] * gp)+
(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
buf2[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gn)+
(buf5[(n-d5)] * gp) + (buf8[(n-d8)] * gn)) * q
buf3[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gp)+
(buf5[(n-d5)] * gn) + (buf8[(n-d8)] * gp)) * q
buf4[n] <- sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn)+
(buf6[(n-d6)] * gn) + (buf7[(n-d7)] * gn)) * q
buf5[n] <- sig[n] + ((buf2[(n-d2)] * gp) + (buf3[(n-d3)] * gp)+
(buf6[(n-d6)] * gn) + (buf7[(n-d7)] * gn)) * q
buf6[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gp)+
(buf5[(n-d5)] * gn) + (buf8[(n-d8)] * gp)) * q
buf7[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gn)+
(buf5[(n-d5)] * gp) + (buf8[(n-d8)] * gp)) * q
buf8[n] <- sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn)+
(buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
n = n + 1
}
plot(preout, type="l")
((buf2[(n-d2)] * gp) + (buf3[(n-d3)] * gp) + (buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
source('~/Desktop/my/FDN/FDN.R')
source('~/Desktop/my/FDN/FDN.R')
buf8
##FDN
n <- bufflength + 1
sig
##4th order FDN reverbrater
library(tuneR)
library(signal)
library(numbers)
setwd("/Users/ryo/Desktop/my/FDN/input")
#set file
prefix <- "/Users/ryo/Desktop/my/FDN/input/"
fnames <- list.files(path=prefix, pattern="*.wav")
for(fname in fnames){
wav <- fname
signal <- readWave(wav)@left
srate <- readWave(wav)@samp.rate
##set parameter
c1_delay <- 31
c1_gain <- 0.6
c2_delay <- 47
c2_gain <- 0.6
c3_delay <- 89
c3_gain <- 0.6
c4_delay <- 97
c4_gain <- 0.5
c5_delay <- 101
c5_gain <- 0.6
c6_delay <- 103
c6_gain <- 0.6
c7_delay <- 107
c7_gain <- 0.6
c8_delay <- 109
c8_gain <- 0.5
cutoff <- 5000
mix <- 0.4
##convert coefficients
d1 <- srate * c1_delay / 1000
d2 <- srate * c2_delay / 1000
d3 <- srate * c3_delay / 1000
d4 <- srate * c4_delay / 1000
d5 <- srate * c5_delay / 1000
d6 <- srate * c6_delay / 1000
d7 <- srate * c7_delay / 1000
d8 <- srate * c8_delay / 1000
g1 <- c1_gain
g2 <- c2_gain
g3 <- c3_gain
g4 <- c4_gain
g5 <- c5_gain
g6 <- c6_gain
g7 <- c7_gain
g8 <- c8_gain
##buffer for maimum delay time
bufflength <- max(d1, d2, d3, d4, d5, d6, d7, d8)
min <- min(d1, d2, d3, d4, d5, d6, d7, d8)
#make buffer
out <- numeric(length(signal))
buf1 <- c(out,out)
buf2 <- buf1
buf3 <- buf1
buf4 <- buf1
buf5 <- buf1
buf6 <- buf1
buf7 <- buf1
buf8 <- buf1
##coefficients of LPF
fn = srate / 2
ff = cutoff / fn
fp = ff * pi
b1 = 1
b2 = 0.12
a1 = 1
a2 = exp((-1) * fp)
norm = (1 - a2) / (b1 + b2)
b1 = b1 * norm
b2 = b2 * norm
##coefficients for matrix
gp = 1 / sqrt(2)
gn = -1 * gp
q = 1 / sqrt(2)
##LPF
n <- 1
while(n <= length(signal)) {
if(n == 1){
out[n] <- signal[n]
n = n + 1
} else {
outb1 <- signal[n] * b1
outb2 <- signal[(n-1)] * b2
out[n] <- outb1 + outb2 + (out[(n-1)] * a2)
n = n + 1
}
}
#fit zero to head
sig <- c(numeric(bufflength), out)
preout <- c(numeric(length(sig)))
##FDN
n <- bufflength + 1
while(n <= length(sig) + min){
preout[n] <- ((((buf1[(n-d1)] * g1) + (buf2[(n-d2)] * g2) + (buf3[(n-d3)] * g3) + (buf4[(n-d4)] * g4) +
(buf5[(n-d5)] * g5) + (buf6[(n-d6)] * g6) + (buf7[(n-d7)] * g7) + (buf8[(n-d8)] * g8)) / 8) * (1 - mix) + (sig[(n - min)] * mix))
buf1[n] <- sig[n] + ((buf2[(n-d2)] * gp) + (buf3[(n-d3)] * gp) + (buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
buf2[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gn) + (buf5[(n-d5)] * gp) + (buf8[(n-d8)] * gn)) * q
buf3[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gp) + (buf5[(n-d5)] * gn) + (buf8[(n-d8)] * gp)) * q
buf4[n] <- sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn) + (buf6[(n-d6)] * gn) + (buf7[(n-d7)] * gn)) * q
buf5[n] <- sig[n] + ((buf2[(n-d2)] * gp) + (buf3[(n-d3)] * gp) + (buf6[(n-d6)] * gn) + (buf7[(n-d7)] * gn)) * q
buf6[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gp) + (buf5[(n-d5)] * gn) + (buf8[(n-d8)] * gp)) * q
buf7[n] <- sig[n] + ((buf1[(n-d1)] * gp) + (buf4[(n-d4)] * gn) + (buf5[(n-d5)] * gp) + (buf8[(n-d8)] * gp)) * q
buf8[n] <- sig[n] + ((buf2[(n-d2)] * gn) + (buf3[(n-d3)] * gn) + (buf6[(n-d6)] * gp) + (buf7[(n-d7)] * gp)) * q
n = n + 1
}
output <- preout[(bufflength + min + 1):(length(sig) + min)]
#save wav
dat <- Wave(left=output, right=output, samp.rate=48000, bit=32, pcm=TRUE)
setwd("/Users/ryo/Desktop/my/FDN/output/4th")
writeWave(normalize(dat, unit="32", center=TRUE), filename=sprintf("%s_%05d.wav",  substring(fname, 1, (nchar(fname)- 4)), cutoff))
setwd("/Users/ryo/Desktop/my/FDN/input")
}
d8
bufflength
min
d1 <- srate * c1_delay / 1000
d1
out <- numeric(length(signal))
buf1 <- c(out,out)
buf1
buf2 <- buf1
buf3 <- buf1
buf4 <- buf1
buf5 <- buf1
buf6 <- buf1
buf7 <- buf1
buf8 <- buf1
source('~/Desktop/my/FDN/FDN.R')
source('~/Desktop/my/FDN/FDN.R')
setwd("/Users/ryo/Desktop/my/FDN/output/4th")
source('~/Desktop/my/FDN/FDN.R')
#set matrix
hadamardF <- function(n){
if(n <= 1){
res <- matrix(0:1, ncol=2)
return(res)
} else {
top <- matrix(c(numeric(2^(n-1)), rep(1,(2^(n-1)))),
nrow=1, ncol=(2^n), byrow=TRUE)
bot <- cbind(hadamardF((n-1)), hadamardF((n-1)))
res <- rbind(top, bot)
return(res)
}
}
hadamard <- function(n) {
F  <- hadamardF(floor(log2(n)))
FF <- t(F)%*%F
FF[FF%%2==1] <- -1
FF[FF%%2==0] <- 1
return(FF)
}
#set coefficients
orders <- 4
P = hadamard(orders)
{Z = matrix(1:16, ncol=4)
for (t in 1:4) {
Z[t,t] <- 0
Z[t, 5-t] <- 0
Z[Z!=0] <- 1
}
k <- orders / 4
Z = matrix(rep(Z, k), nrow=4)
for(t in 1:4){
Z = rbind(Z,Z[t,])
}
}
R = P * Z
P
Z
{Z = matrix(1:16, ncol=4)
for (t in 1:4) {
Z[t,t] <- 0
Z[t, 5-t] <- 0
Z[Z!=0] <- 1
}
k <- orders / 4
Z = matrix(rep(Z, k), nrow=4)
for(t in 1:4){
Z = rbind(Z,Z[t,])
}
}
Z
rep(Z, k)
Z = matrix(rep(Z, k), nrow=4)
Z
Z = rbind(Z,Z[t,])
Z
#set coefficients
orders <- 4
{Z = matrix(1:16, ncol=4)
for (t in 1:4) {
Z[t,t] <- 0
Z[t, 5-t] <- 0
Z[Z!=0] <- 1
}
k <- orders / 4
Z = matrix(rep(Z, k), nrow=4)
for(t in 1:4){
Z = rbind(Z,Z[t,])
}
}
R = P * Z
Z
P
source('~/Desktop/my/FDN/FDN.R')
source('~/Desktop/my/FDN/FDN.R')
q = 0.4
source('~/Desktop/my/FDN/FDN.R')
1 / sqrt(2)
source('~/Desktop/my/FDN/FDN.R')
source('~/Desktop/my/FDN/FDN.R')
source('~/Desktop/my/FDN/FDN.R')
P = hadamard(orders)
#set coefficients
orders <- 8
P = hadamard(orders)
P
source('~/Desktop/my/FDN/FDN.R')
source('~/Desktop/my/FDN/FDN_nth_order.R')
feedback / sqrt(2)
feedback / sqrt(2)
G
source('~/Desktop/my/FDN/FDN_nth_order.R')
source('~/Desktop/my/FDN/FDN.R')
source('~/Desktop/my/FDN/FDN.R')
source('~/Desktop/my/FDN/FDN.R')
##set parameter
delaytimes <- c(13, 49, 71, 97, 101, 103, 107, 109)
c1_delay <- delaytime[1]
c1_delay <- delaytimes[1]
gains      <- c(0.8, 0.6, 0.6, 0.5, 0.5, 0.5, 0.4, 0.4)
c1_delay <- delaytimes[1]
c1_delay
